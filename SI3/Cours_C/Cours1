M-x compile
make -k
gcc -Wall -o prog prog.c  (prog.c = exemple)

3 types d'erreurs :
-orthographe
-syntaxe
-sémantique

axiome de Hoore



#include <stdlib.h>
#include <stdio.h>
ce n'est pas du C c'est pour le préprocesseur
fichiers d'entrées ou d'inclusion ou d'en-tête qui existent
io = input output
dans fichiers.h jamais d'instructions

stdlib. --> exit_success

déclaration d'une fonction
int main (void) {  une forme d'entête qu'on utilisera
void = pas de paramètres

C est permissif i.e laisse passer beaucoup de choses

il existe 3 notations des nombres
décimale
octale
héxadécimale que pour les entiers

pas de type string

type entier:
-short
-long
-int

commande floor:


<math.h> ce n'est pas une bibliothèque!  "h" --> header
sqrt fonction déjà compilé qui lui est dans une bibliothèque

ld : loader à la fin c'est l'édition pour charger les fonctions utilisées

ATTENTION SOUSTRACTION :
il faut éviter et essayer de modifier l'algorithme
ATTENTION aussi au test d'égalité
 
expression :
- formule où il y a des opérandes et des opérations 
- puis on évalue l'opération qui donne un résultat

exemple : énoncé conditionnelle if then else on peut le remplacer par une expression conditionnelle
if (a==b)
	c = v1
else
	c = v2
peut être remplacé par
c = (a==b)? v1:v2
mais il faut obligatoirement un sinon

sortie d'erreur standard : stderr
il faut écrire tous les messages d'erreur sur ça
ex : fprintf(stderr, "sfsg")

fonction procédurale:
suite d'instruction qui ont un NOM
on va pouvoir utiliser cette fonction grâce à son nom

programme : données --> résultats
les données sont prises sur l'entrée standard (souvent clavier)
résultats --> sortie standard

pour une fonction procédurale
les données sont prises à partir de
résultats --> 

une fonction f prend des données et donne des résultats

on peut appeler de fonction de procédure

Intérêts:
- structuration des programmes (C est procédural)
i.e programme résout un problème qui a une certaine complexité, on découpe le problème en sous-problème ect... jusqu'à avoir un sous-sous... problème qui a une complexité simple. Donc on peut
faire un programme "assez" simple avec une tâche particulière
C = une suite de procédures
- autre intérêt : localisation 
c'est à dire certaines fonctions ou variables n'ont besoin d'exister que dans la procédure ou fonction --> permet d'éviter erreurs ou de déclarer des variables qui seront inutiles (suivant le 
cadre de leur utilisation)
- paramétrage
permet de donner des résultats différernts à partir d'une même fonction
permet de s'adapter à différents cas

2 parties pour les foncions procédurales:

déclaration puis utilisation

1)déclaration
en tête indique nom,paramètres (formelle,donnée ou sortie,type),type des données d'entrée et de retour
puis le corps de la fonction

fonction pas forcément de paramètre sortie
procédure paramètre sortie et entrée
dans l'utilisation les paramètres sont dits effectifs sinon ils sont formelles

Règle général: il y a des exceptions
- nombre de paramètre formelle et effectif : égal
- ordre dans la déclaration des paramètres
- pour les langages typé comme c il faut qu'il y est compatibilité dans le type du paramètre formel
et effectif
- mode de transmission :
pour les données : transmission par valeur --> évaluer paramètre effectif pour la transmettre dans 
le paramètre formelle
tout ce passe comme si avant corps x reçoit telle valeur ect...
transmission par résultat --> tout ce passe comme si après corps z reçoit telle valeur ect... c'est 
nécessairement une variable à mettre pour résultat.

en c il n'y a que des transmissions par valeur et il n'y a pas de procédure
en c il y a paramètre donnée et résultat


énoncé itératif : répéter une suite d'instruction plusieurs fois
arrêt dépend condition d'arrêt ou prédicat d'achèvement
invariant = affirmations vraies quelque soit le nombre d'itération
L'Invariant de boucle est celui qui est juste avant la condition d'arrêt : il décrit sémantique de la boucle
Il faut s'assurer que la boucle termine, pour cela il faut une fonction strictement décroissante
à valeur positive

En premier lieu il faut poser l'invariant de boucle puis s'assurer de la terminaison

2 formes de boucles :
- rien avant le prédicat d'achèvement --> while
- rien après le prédicat d'achèvement -->

1) while  (( en C while (B) E ))
{ P } tant que B faire E fin tant que { P et B barre }
invariant c'est P car juste avant B (c'est aussi l'antécédent) et P et B barre = conséquent
2) répétition   (( en C do E while (B) ))
{P} répéter E jusqu'à B {Q et B}
Q = invariant de boucle
{P} E {Q} et {Q} E {Q} ???
do while on fait au moins une action



Entrée et sortie standard
on a vu printf et scanf
getchar() --> lit et renvoie le prochain octet (entrée standard) 
putchar() --> écrit le prochain caractère en fin de fichier (sortie standard)
en C les caractères sont représentés par des octets
size(char) = 1 tjs en C

algo qui lit tout les caractères ou octets d'un fichier:
si fdf = fin de fichier
tant que non fdf faire
	lire(c)
	traiter(c)
fin tant que

en C :
int c; //un caractère peut être signé, non signé ou pseudo-signé et int est signé
while ((c=getchar())!=EOF){ //EOF end of file souvent égal à -1 donc c doit être signé
	traiter(c);

sous linux ctrl-d marque la fin d'un fichier

redirection:
$./prog < f  -->  au lieu de taper à chaque fois au clavier on peut rediriger vers un fichier
redirection se fait par le "<"


ORDINAL : indique le numéro d'ordre du caractère
en ASCI c'est sur 7 bits

en ISO? c'est sur 8 bits par exemple
c-'0' conversion implicite

conséqent d'une affectation = 

07/01/2019

pour le tant que ou le répéter on ne connaît pas le nombre d'itérations on doit s'assurer que ça termine
pas pour l'énoncer pour
exemple pour tout x dans Type faire Enoncé fin pour tout
en C : for (e1;e2;e3) E <=> e1; while (e2) { E; e3; } e2 c'est le prédicat d'achèvement
exemple en C : for (int i = -3; i<7 ; i++) i n'existe que dans la boucle sinon on pourrait utiliser i ailleurs et ça peut poser des problèmes

Tableau:

type simple ou élémentaire : dépend de l'accès si on peut accéder à toute la valeur à travers une variable alors c'est un type simple exemple les entiers

ici les tableaux sont des types structurés on n'accède à une partie seulement
nombre de composants finis
les éléments sont de même types
accessible avec un inddex, indice, c'est indexé

ex : type tableau [T1] de T2 : card(T1) éléments  et chaque élément de type T2
le type de T1 doit nécesserairement être de type simple exemple des entiers

ex t1 : tableau[caractère] de réel (si sur 8 bits alors 256 éléments) ect..

comment accéder aux éléments?
t[i] i est un indice calculé i.e une expression qui appartient à T1
il faut s'assurer que i appartiennent à T1 car si ce n'est pas le cas on ne le saura qu'au moment de l'exécution (pourquoi pas la compilation) et là c'est peut être trop tard

En C : 
T t[N]; N : nombre d'éléments N entier
t[i] i dans [0;N-1] le langage c ne dit pas où est le problème:
2 cas : - soit erreur
	- soit pas erreur : 2 cas : - 
				  

t désigne le premier élément du tableau on verra plus en détail pourquoi
ex : int t1[N], t2[N]
on affecte des valeurs à t2 et on fait t1 = t2 --> ça ne marche pas il faut faire une procédure (for par ex) erreur compilation

un seul mode de transmission en c : c'est par valeur pour les données
cf photo code qui initialise tab à 0


tac inverse de cat : affiche contenu d'un fichier ligne par ligne en sens inverse 

Entrée standard --> Sortie standard

int t1[N]
int t2[M][N] --> tableau de M tableaux de N entiers
t2[i] --> ie élément qui est un tableau
M ligne de la matrice, N colonne de la matrice
parcourir tout les éléments : deux boucles imbriquées

for (int i=0 ; i<M ; i++)
  for (int j=0 ; j<N ; j++)
    mat[i][j] 
