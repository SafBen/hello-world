concurrent     	    	!=  		parallèle
pas certains que ce 			vraiment parallèle         
soit parallèle physiquement		séparer problème et
					pour accélérer


page 5
sequentiel avec un seul thread => dans la réalité décodage parallèle

pas même horloge et/ou mémoire


threads qui partagent rien => programme correct
si accès pas en même temps => correct
si accès en même temps => faux

donc il faut d'abord voir quelles sont les données qui sont partagées
on découpe en 2 propriétés:
Sureté:
si on ne fait que lire ça va
ou si une écriture avec même valeur
ou si mutuelle exclusion

1er réflexe:
qu'est qui en commun?
si oui est ce que c'est modifié?

page 10
code
si une personne ça va mais pas si plusieurs

page 12
1er et 2e problème doivent être résolus absolument
1er entrelacement => montré qu'il n'y en a pas
1 ressource => pas d'interblocage possible => à partir de 2 => montrer qu'il n'y a pas d'interblocage
3e problème à résoudre que si surchargé



2 bibliothèques Python 
multiprocessing
thread

comment compilateur éxécute
les entrelacements

page 17



ATTENTION POUR LE CODE : IL FAUT TOUJOURS LIBÉRER LE VERROU MÊME SI EXCEPTION SINON LE CODE NE VA PAS À LA FIN DE LA FONCTION ET DONC LE VERROU N'EST PAS LIBÉRER




sémaphore

3 utilisations
-initialisé à 1 : comme verrou
-initialisé à 0
-initialisé à m savoir combien de fois je peux utiliser une ressource

JAVA le sémaphore peut être équitable ou non : si non => utilise pile sinon file


attente active peut être plus rapide



while avec notifyAll
if avec notify
MAIS if peut ne pas marché donc on utilise while




